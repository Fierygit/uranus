<!--
 * @Author: Firefly
 * @Date: 2020-03-30 21:16:32
 * @Descripttion: 
 * @LastEditTime: 2020-03-30 21:55:53
 -->
# Lab1 test report

## 1. 实验概要

&emsp;&emsp;多线程编程是高性能编程的技术之一，实验1将针对数独求解问题比较多线程与单线程的性能差异、同一功能不同代码实现的性能差异以及多线程在不同硬件环境下的性能差异。

### 1.1 程序输入
&emsp;&emsp;程序将在控制台接收用户输入，该输入应为某一目录下的一个数独谜题文件，该文件包含多个数独谜题，每个数独谜题按固定格式存储在该文件中。

### 1.2 程序输出

&emsp;&emsp;实验中把数独的解按与输入相对应的顺序写入到std。

### 1.3 Sudoku算法

&emsp;&emsp; 本次实验我们小组使用了 DANCEING LINK 算法

### 1.4 性能指标

&emsp;&emsp;实验以求解完单个输入文件里的所有数独题并把数独的解按顺序写入文件所需要的时间开销作为性能指标。一般而言，可以用加速比直观地表示并行程序与串行程序之间的性能差异（加速比：串行执行时间与并行执行时间的比率，是串行与并行执行时间之间一个具体的比较指标）。

&emsp;&emsp;为了精确地测量性能，时间开销均在数独求解进程/线程绑定CPU的某个核的条件下测得，这样保证了该进程/线程不被调度到其他核中运行，但不保证该进程/线程独占某个核。更精确的测量方法可以先把CPU的某个核隔离，而后再绑定在某个进程/线程上，这样该CPU核心不会运行其他的用户程序。当CPU资源充足时（CPU核心数足够多，当前正在运行的进程/线程足够少），是否把核隔离并没有多大影响，因为操作系统的调度策略不会频繁的对线程/进程进行无谓的调度。

### 1.5 实验环境

&emsp;&emsp; 不同小组成员使用的环境不同（下面有标注）




### 1.6 代码实现版本

&emsp;&emsp;实验中共使用两份不同的代码：**Code1**和**Code2**。

&emsp;&emsp;**Code1:** 原生的数独求解代码，即本实验中所提供的代码，只能以单线程模式运行。

&emsp;&emsp;**Code2:** 使用一个线程池接受任务，并且初始创建n个线程



## 2. 性能测试

为了测试出不同环境和平台情况下， 多线程处理的情况，我们小组每位同学都进行了测试

### 实验代码使用单线程与原始代码作比较

实验环境: wsl ubantu 4core 4 thread 


- 实验代码解决5000个数独：  1.14996

- 原始代码解决5000个数独：  0.413811

可以看出，我们的单线程代码比原来的代码时间多了一倍！

原因: 当使用条件变量和锁的时候，任务的获取会有时间消耗， 除此之外，我们的代码还比原来的代码还多了一份复制， 因此，时间上又会慢一点， 如果将这些时间均摊到一份巨大的任务上并用多线程，那么这些多线程的优势才会体现出来了， 具体看下面的评测！

### 综合数据对比评测 - from 吴嘉豪

```
Architecture:        x86_64
CPU op-mode(s):      32-bit, 64-bit
Byte Order:          Little Endian
CPU(s):              4
On-line CPU(s) list: 0-3
Thread(s) per core:  2
Core(s) per socket:  2
Socket(s):           1
Vendor ID:           GenuineIntel
CPU family:          6
Model:               142
Model name:          Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz
Stepping:            9
CPU MHz:             2701.000
CPU max MHz:         2701.0000
BogoMIPS:            5402.00
Virtualization:      VT-x
Hypervisor vendor:   Windows Subsystem for Linux
Virtualization type: container
Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave osxsave avx f16c rdrand lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx rdseed adx smap clflushopt intel_pt ibrs ibpb stibp ssbd
```

下表中, 数据量为数独问题的数量, 线程数为线程池中开启的线程数, 平均时间为以上述条件多次测试取平均值的执行时间(不包括数据IO)

| 序号 | 数据量 | 线程数 | 平均时间 |
| ---- | ------ | ------ | -------- |
| 1    | 1      | 1      | 0.00147  |
| 2    | 1      | 2      | 0.00169  |
| 3    | 1      | 3      | 0.00207  |
| 4    | 1      | 4      | 0.00239  |
| 5    | 1      | 5      | 0.003052 |
| 6    | 1      | 6      | 0.003583 |
| 7    | 100    | 1      | 0.01033  |
| 8    | 100    | 2      | 0.007017 |
| 9    | 100    | 3      | 0.004951 |
| 10   | 100    | 4      | 0.008432 |
| 11   | 100    | 5      | 0.007258 |
| 12   | 100    | 6      | 0.009542 |
| 13   | 1000   | 1      | 0.094041 |
| 14   | 1000   | 2      | 0.055634 |
| 15   | 1000   | 3      | 0.042375 |
| 16   | 1000   | 4      | 0.037539 |
| 17   | 1000   | 5      | 0.032876 |
| 18   | 1000   | 6      | 0.039525 |
| 19   | 10000  | 1      | 0.835913 |
| 20   | 10000  | 2      | 0.553967 |
| 21   | 10000  | 3      | 0.377475 |
| 22   | 10000  | 4      | 0.389515 |
| 23   | 10000  | 5      | 0.332054 |
| 24   | 10000  | 6      | 0.381459 |

从上述表格中可以归纳出如下规律:

1. 对于只有1个任务的情况, 时间线性递增, 是因为有了线程池多个线程创建的开销
2. 对于多任务的情况, 从任务100到任务10000个, 时间从线程1开始递减, 直到线程数为5时时间是最低点, 线程数为6时时间递增.
3. 数据规模线性增大时, 如从1000个任务到10000个任务, 时间几乎是成比例减小的
4. 但是当线程数增大时, 时间没有呈比例减小


### 超大规模数独问题的解 - 赖祯梁

测试环境： （CPU为4核4线程）

解决问题规模为1000000的数独问题时，
花费的时间是：
1个线程为87.6314s，
2个线程为43.7063s，
3个线程为29.5073s，
4个线程为21.6176s,（时间最短）
5个线程为27.9215s，
6个线程为30.8516s，
8个线程为28.4021s。

可以看到当线程池创建的线程数小于等于CPU核心数时，运行时间与线程数成比例，且当线程数等于核心数、四个线程时最快。当线程数大于核心数时时间下降，原因可能是线程之间的切换花费了一些时间。总体来说多线程对于加快解决问题有很大的帮助，但是需要与机器的核心数相匹配才能发挥出多线程的最大效益。


### 电脑运行繁忙的时候

实验环境: wsl ubantu 4core 4 thread

当电脑的cpu 被其它不相关的进程占用很多资源的时候， 效果会如何呢？ 下面是测试 5000个的样例



- 低cpu占用（< 30%）

- - 1个线程 time: 1.0885

- - 4个线程 time: 0.461187

加速比： 2.3602

- 高cpu占用（>= 50%）

- - 1个线程 time: 1.25037

- - 4个线程 time: 0.639527

加速比： 1.9551

总结： 加速比变低， 其它进程抢占了， cpu 时间
