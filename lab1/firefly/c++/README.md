<!--
 * @Author: Firefly
 * @Date: 2020-02-27 16:10:26
 * @Descripttion: 
 * @LastEditTime: 2020-02-27 16:21:54
 -->

### 测试时间（都是1000个样例的）

- 回溯：  jameywoo 竟然跑了，   要20分钟
- min_arity_cache               2.7s
- min_arity                     7.2s
- dancing links 算法最快        0.05s


### 实现多线程思路

- 复杂高效实现：

1. c++ 的线程调用是基于os的调度，即为 1 ： 1 的调度， 因此cpu有多少核就创建多少多少线程， 以减少线程的切换带来时间开销, 因此第一步获取os的cpu核心数

2. 创建线程池， 将所有任务加入等待队列


- 简单（但线程的创建需要时间）：

1. 保持让4个线程活跃， 当某一个线程计算完了， 再开新的线程
